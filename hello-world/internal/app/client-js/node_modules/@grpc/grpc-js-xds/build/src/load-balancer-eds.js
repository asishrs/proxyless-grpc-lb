"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.EdsLoadBalancer = exports.EdsLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_client_1 = require("./xds-client");
const load_balancer_priority_1 = require("./load-balancer-priority");
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var subchannelAddressToString = grpc_js_1.experimental.subchannelAddressToString;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var PickResultType = grpc_js_1.experimental.PickResultType;
const experimental_1 = require("@grpc/grpc-js/build/src/experimental");
const load_balancer_weighted_target_1 = require("./load-balancer-weighted-target");
const load_balancer_lrs_1 = require("./load-balancer-lrs");
const TRACER_NAME = 'eds_balancer';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'eds';
function localityToName(locality) {
    return `{region=${locality.region},zone=${locality.zone},sub_zone=${locality.sub_zone}}`;
}
class EdsLoadBalancingConfig {
    constructor(cluster, localityPickingPolicy, endpointPickingPolicy, edsServiceName, lrsLoadReportingServerName) {
        this.cluster = cluster;
        this.localityPickingPolicy = localityPickingPolicy;
        this.endpointPickingPolicy = endpointPickingPolicy;
        this.edsServiceName = edsServiceName;
        this.lrsLoadReportingServerName = lrsLoadReportingServerName;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        const jsonObj = {
            cluster: this.cluster,
            locality_picking_policy: this.localityPickingPolicy.map(policy => policy.toJsonObject()),
            endpoint_picking_policy: this.endpointPickingPolicy.map(policy => policy.toJsonObject())
        };
        if (this.edsServiceName !== undefined) {
            jsonObj.eds_service_name = this.edsServiceName;
        }
        if (this.lrsLoadReportingServerName !== undefined) {
            jsonObj.lrs_load_reporting_server_name = this.lrsLoadReportingServerName;
        }
        return {
            [TYPE_NAME]: jsonObj
        };
    }
    getCluster() {
        return this.cluster;
    }
    getLocalityPickingPolicy() {
        return this.localityPickingPolicy;
    }
    getEndpointPickingPolicy() {
        return this.endpointPickingPolicy;
    }
    getEdsServiceName() {
        return this.edsServiceName;
    }
    getLrsLoadReportingServerName() {
        return this.lrsLoadReportingServerName;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('eds config must have a string field cluster');
        }
        if (!('locality_picking_policy' in obj && Array.isArray(obj.locality_picking_policy))) {
            throw new Error('eds config must have a locality_picking_policy array');
        }
        if (!('endpoint_picking_policy' in obj && Array.isArray(obj.endpoint_picking_policy))) {
            throw new Error('eds config must have an endpoint_picking_policy array');
        }
        if ('eds_service_name' in obj && !(obj.eds_service_name === undefined || typeof obj.eds_service_name === 'string')) {
            throw new Error('eds config eds_service_name field must be a string if provided');
        }
        if ('lrs_load_reporting_server_name' in obj && (!obj.lrs_load_reporting_server_name === undefined || typeof obj.lrs_load_reporting_server_name === 'string')) {
            throw new Error('eds config lrs_load_reporting_server_name must be a string if provided');
        }
        return new EdsLoadBalancingConfig(obj.cluster, obj.locality_picking_policy.map(experimental_1.validateLoadBalancingConfig), obj.endpoint_picking_policy.map(experimental_1.validateLoadBalancingConfig), obj.eds_service_name, obj.lrs_load_reporting_server_name);
    }
}
exports.EdsLoadBalancingConfig = EdsLoadBalancingConfig;
/**
 * This class load balances over a cluster by making an EDS request and then
 * transforming the result into a configuration for another load balancing
 * policy.
 */
class EdsLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.edsServiceName = null;
        /**
         * Indicates whether the watcher has already been passed to the xdsClient
         * and is getting updates.
         */
        this.isWatcherActive = false;
        this.lastestConfig = null;
        this.latestAttributes = {};
        this.latestEdsUpdate = null;
        /**
         * The priority of each locality the last time we got an update.
         */
        this.localityPriorities = new Map();
        /**
         * The name we assigned to each priority number the last time we got an
         * update.
         */
        this.priorityNames = [];
        this.nextPriorityChildNumber = 0;
        this.clusterDropStats = null;
        this.childBalancer = new ChildLoadBalancerHandler({
            createSubchannel: (subchannelAddress, subchannelArgs) => this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs),
            requestReresolution: () => this.channelControlHelper.requestReresolution(),
            updateState: (connectivityState, originalPicker) => {
                if (this.latestEdsUpdate === null) {
                    return;
                }
                const edsPicker = {
                    pick: (pickArgs) => {
                        var _a;
                        const dropCategory = this.checkForDrop();
                        /* If we drop the call, it ends with an UNAVAILABLE status.
                         * Otherwise, delegate picking the subchannel to the child
                         * balancer. */
                        if (dropCategory === null) {
                            return originalPicker.pick(pickArgs);
                        }
                        else {
                            (_a = this.clusterDropStats) === null || _a === void 0 ? void 0 : _a.addCallDropped(dropCategory);
                            return {
                                pickResultType: PickResultType.DROP,
                                status: {
                                    code: grpc_js_1.status.UNAVAILABLE,
                                    details: `Call dropped by load balancing policy. Category: ${dropCategory}`,
                                    metadata: new grpc_js_1.Metadata(),
                                },
                                subchannel: null,
                                extraFilterFactory: null,
                                onCallStarted: null,
                            };
                        }
                    },
                };
                this.channelControlHelper.updateState(connectivityState, edsPicker);
            },
        });
        this.watcher = {
            onValidUpdate: (update) => {
                trace('Received EDS update for ' + this.edsServiceName + ': ' + JSON.stringify(update, undefined, 2));
                this.latestEdsUpdate = update;
                this.updateChild();
            },
            onResourceDoesNotExist: () => {
                this.isWatcherActive = false;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: 'EDS resource does not exist', metadata: new grpc_js_1.Metadata() }));
                this.childBalancer.destroy();
            },
            onTransientError: (status) => {
                if (this.latestEdsUpdate === null) {
                    channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({
                        code: grpc_js_1.status.UNAVAILABLE,
                        details: `xDS request failed with error ${status.details}`,
                        metadata: new grpc_js_1.Metadata(),
                    }));
                }
            },
        };
    }
    /**
     * Check whether a single call should be dropped according to the current
     * policy, based on randomly chosen numbers. Returns the drop category if
     * the call should be dropped, and null otherwise.
     */
    checkForDrop() {
        var _a;
        if (!((_a = this.latestEdsUpdate) === null || _a === void 0 ? void 0 : _a.policy)) {
            return null;
        }
        /* The drop_overloads policy is a list of pairs of category names and
         * probabilities. For each one, if the random number is within that
         * probability range, we drop the call citing that category. Otherwise, the
         * call proceeds as usual. */
        for (const dropOverload of this.latestEdsUpdate.policy.drop_overloads) {
            if (!dropOverload.drop_percentage) {
                continue;
            }
            let randNum;
            switch (dropOverload.drop_percentage.denominator) {
                case 'HUNDRED':
                    randNum = Math.random() * 100;
                    break;
                case 'TEN_THOUSAND':
                    randNum = Math.random() * 10000;
                    break;
                case 'MILLION':
                    randNum = Math.random() * 1000000;
                    break;
                default:
                    continue;
            }
            if (randNum < dropOverload.drop_percentage.numerator) {
                return dropOverload.category;
            }
        }
        return null;
    }
    /**
     * Should be called when this balancer gets a new config and when the
     * XdsClient returns a new ClusterLoadAssignment.
     */
    updateChild() {
        var _a;
        if (!(this.lastestConfig && this.latestEdsUpdate)) {
            return;
        }
        /**
         * Maps each priority number to the list of localities with that priority,
         * and the list of addresses associated with each locality.
         */
        const priorityList = [];
        /**
         * New replacement for this.localityPriorities, mapping locality names to
         * priority values. The replacement occurrs at the end of this method.
         */
        const newLocalityPriorities = new Map();
        /* We are given a list of localities, each of which has a priority. This
         * loop consolidates localities into buckets by priority, while also
         * simplifying the data structure to make the later steps simpler */
        for (const endpoint of this.latestEdsUpdate.endpoints) {
            if (!endpoint.load_balancing_weight) {
                continue;
            }
            const addresses = endpoint.lb_endpoints.filter(lbEndpoint => lbEndpoint.health_status === 'UNKNOWN' || lbEndpoint.health_status === 'HEALTHY').map((lbEndpoint) => {
                /* The validator in the XdsClient class ensures that each endpoint has
                 * a socket_address with an IP address and a port_value. */
                const socketAddress = lbEndpoint.endpoint.address.socket_address;
                return {
                    host: socketAddress.address,
                    port: socketAddress.port_value,
                };
            });
            if (addresses.length > 0) {
                let localityArray = priorityList[endpoint.priority];
                if (localityArray === undefined) {
                    localityArray = [];
                    priorityList[endpoint.priority] = localityArray;
                }
                localityArray.push({
                    locality: endpoint.locality,
                    addresses: addresses,
                    weight: endpoint.load_balancing_weight.value,
                });
                newLocalityPriorities.set(localityToName(endpoint.locality), endpoint.priority);
            }
        }
        const newPriorityNames = [];
        const addressList = [];
        const priorityChildren = new Map();
        /* The algorithm here is as follows: for each priority we are given, from
         * high to low:
         * - If the previous mapping had any of the same localities at the same or
         *   a lower priority, use the matching name from the highest such
         *   priority, unless the new mapping has already used that name.
         * - Otherwise, construct a new name using this.nextPriorityChildNumber.
         */
        for (const [priority, localityArray] of priorityList.entries()) {
            // Skip priorities that have no localities with healthy endpoints
            if (localityArray === undefined) {
                continue;
            }
            /**
             * Highest (smallest number) priority value that any of the localities in
             * this locality array had a in the previous mapping.
             */
            let highestOldPriority = Infinity;
            for (const localityObj of localityArray) {
                const oldPriority = this.localityPriorities.get(localityToName(localityObj.locality));
                if (oldPriority !== undefined &&
                    oldPriority >= priority &&
                    oldPriority < highestOldPriority) {
                    highestOldPriority = oldPriority;
                }
            }
            let newPriorityName;
            if (highestOldPriority === Infinity) {
                /* No existing priority at or below the same number as the priority we
                 * are looking at had any of the localities in this priority. So, we
                 * use a new name. */
                newPriorityName = `child${this.nextPriorityChildNumber++}`;
            }
            else {
                const newName = this.priorityNames[highestOldPriority];
                if (newPriorityNames.indexOf(newName) < 0) {
                    newPriorityName = newName;
                }
                else {
                    newPriorityName = `child${this.nextPriorityChildNumber++}`;
                }
            }
            newPriorityNames[priority] = newPriorityName;
            const childTargets = new Map();
            for (const localityObj of localityArray) {
                /* Use the endpoint picking policy from the config, default to
                 * round_robin. */
                const endpointPickingPolicy = [
                    ...this.lastestConfig.getEndpointPickingPolicy(),
                    experimental_1.validateLoadBalancingConfig({ round_robin: {} }),
                ];
                let childPolicy;
                if (this.lastestConfig.getLrsLoadReportingServerName() !== undefined) {
                    childPolicy = [new load_balancer_lrs_1.LrsLoadBalancingConfig(this.lastestConfig.getCluster(), (_a = this.lastestConfig.getEdsServiceName()) !== null && _a !== void 0 ? _a : '', this.lastestConfig.getLrsLoadReportingServerName(), localityObj.locality, endpointPickingPolicy)];
                }
                else {
                    childPolicy = endpointPickingPolicy;
                }
                childTargets.set(localityToName(localityObj.locality), {
                    weight: localityObj.weight,
                    child_policy: childPolicy,
                });
                for (const address of localityObj.addresses) {
                    addressList.push(Object.assign({ localityPath: [
                            newPriorityName,
                            localityToName(localityObj.locality),
                        ] }, address));
                }
            }
            priorityChildren.set(newPriorityName, {
                config: [
                    new load_balancer_weighted_target_1.WeightedTargetLoadBalancingConfig(childTargets),
                ],
            });
        }
        /* Contract the priority names array if it is sparse. This config only
         * cares about the order of priorities, not their specific numbers */
        const childConfig = new load_balancer_priority_1.PriorityLoadBalancingConfig(priorityChildren, newPriorityNames.filter((value) => value !== undefined));
        trace('Child update addresses: ' + addressList.map(address => '(' + subchannelAddressToString(address) + ' path=' + address.localityPath + ')'));
        trace('Child update priority config: ' + JSON.stringify(childConfig.toJsonObject(), undefined, 2));
        this.childBalancer.updateAddressList(addressList, childConfig, this.latestAttributes);
        this.localityPriorities = newLocalityPriorities;
        this.priorityNames = newPriorityNames;
    }
    updateAddressList(addressList, lbConfig, attributes) {
        var _a, _b;
        if (!(lbConfig instanceof EdsLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
            return;
        }
        trace('Received update with config: ' + JSON.stringify(lbConfig, undefined, 2));
        this.lastestConfig = lbConfig;
        this.latestAttributes = attributes;
        const newEdsServiceName = (_a = lbConfig.getEdsServiceName()) !== null && _a !== void 0 ? _a : lbConfig.getCluster();
        /* If the name is changing, disable the old watcher before adding the new
         * one */
        if (this.isWatcherActive && this.edsServiceName !== newEdsServiceName) {
            trace('Removing old endpoint watcher for edsServiceName ' + this.edsServiceName);
            xds_client_1.getSingletonXdsClient().removeEndpointWatcher(this.edsServiceName, this.watcher);
            /* Setting isWatcherActive to false here lets us have one code path for
             * calling addEndpointWatcher */
            this.isWatcherActive = false;
            /* If we have a new name, the latestEdsUpdate does not correspond to
             * the new config, so it is no longer valid */
            this.latestEdsUpdate = null;
        }
        this.edsServiceName = newEdsServiceName;
        if (!this.isWatcherActive) {
            trace('Adding new endpoint watcher for edsServiceName ' + this.edsServiceName);
            xds_client_1.getSingletonXdsClient().addEndpointWatcher(this.edsServiceName, this.watcher);
            this.isWatcherActive = true;
        }
        if (lbConfig.getLrsLoadReportingServerName()) {
            this.clusterDropStats = xds_client_1.getSingletonXdsClient().addClusterDropStats(lbConfig.getLrsLoadReportingServerName(), lbConfig.getCluster(), (_b = lbConfig.getEdsServiceName()) !== null && _b !== void 0 ? _b : '');
        }
        /* If updateAddressList is called after receiving an update and the update
         * is still valid, we want to update the child config with the information
         * in the new EdsLoadBalancingConfig. */
        this.updateChild();
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        trace('Destroying load balancer with edsServiceName ' + this.edsServiceName);
        if (this.edsServiceName) {
            xds_client_1.getSingletonXdsClient().removeEndpointWatcher(this.edsServiceName, this.watcher);
        }
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.EdsLoadBalancer = EdsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, EdsLoadBalancer, EdsLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-eds.js.map