"use strict";
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = exports._envoy_api_v2_Cluster_LbPolicy = exports._envoy_api_v2_Cluster_RingHashLbConfig_HashFunction = exports._envoy_api_v2_Cluster_DnsLookupFamily = exports._envoy_api_v2_Cluster_DiscoveryType = exports._envoy_api_v2_Cluster_ClusterProtocolSelection = void 0;
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
var _envoy_api_v2_Cluster_ClusterProtocolSelection;
(function (_envoy_api_v2_Cluster_ClusterProtocolSelection) {
    /**
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options <envoy_api_field_Cluster.http2_protocol_options>` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     */
    _envoy_api_v2_Cluster_ClusterProtocolSelection[_envoy_api_v2_Cluster_ClusterProtocolSelection["USE_CONFIGURED_PROTOCOL"] = 0] = "USE_CONFIGURED_PROTOCOL";
    /**
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     */
    _envoy_api_v2_Cluster_ClusterProtocolSelection[_envoy_api_v2_Cluster_ClusterProtocolSelection["USE_DOWNSTREAM_PROTOCOL"] = 1] = "USE_DOWNSTREAM_PROTOCOL";
})(_envoy_api_v2_Cluster_ClusterProtocolSelection = exports._envoy_api_v2_Cluster_ClusterProtocolSelection || (exports._envoy_api_v2_Cluster_ClusterProtocolSelection = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 */
var _envoy_api_v2_Cluster_DiscoveryType;
(function (_envoy_api_v2_Cluster_DiscoveryType) {
    /**
     * Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_DiscoveryType[_envoy_api_v2_Cluster_DiscoveryType["STATIC"] = 0] = "STATIC";
    /**
     * Refer to the :ref:`strict DNS discovery
     * type<arch_overview_service_discovery_types_strict_dns>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_DiscoveryType[_envoy_api_v2_Cluster_DiscoveryType["STRICT_DNS"] = 1] = "STRICT_DNS";
    /**
     * Refer to the :ref:`logical DNS discovery
     * type<arch_overview_service_discovery_types_logical_dns>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_DiscoveryType[_envoy_api_v2_Cluster_DiscoveryType["LOGICAL_DNS"] = 2] = "LOGICAL_DNS";
    /**
     * Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_DiscoveryType[_envoy_api_v2_Cluster_DiscoveryType["EDS"] = 3] = "EDS";
    /**
     * Refer to the :ref:`original destination discovery
     * type<arch_overview_service_discovery_types_original_destination>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_DiscoveryType[_envoy_api_v2_Cluster_DiscoveryType["ORIGINAL_DST"] = 4] = "ORIGINAL_DST";
})(_envoy_api_v2_Cluster_DiscoveryType = exports._envoy_api_v2_Cluster_DiscoveryType || (exports._envoy_api_v2_Cluster_DiscoveryType = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 */
var _envoy_api_v2_Cluster_DnsLookupFamily;
(function (_envoy_api_v2_Cluster_DnsLookupFamily) {
    _envoy_api_v2_Cluster_DnsLookupFamily[_envoy_api_v2_Cluster_DnsLookupFamily["AUTO"] = 0] = "AUTO";
    _envoy_api_v2_Cluster_DnsLookupFamily[_envoy_api_v2_Cluster_DnsLookupFamily["V4_ONLY"] = 1] = "V4_ONLY";
    _envoy_api_v2_Cluster_DnsLookupFamily[_envoy_api_v2_Cluster_DnsLookupFamily["V6_ONLY"] = 2] = "V6_ONLY";
})(_envoy_api_v2_Cluster_DnsLookupFamily = exports._envoy_api_v2_Cluster_DnsLookupFamily || (exports._envoy_api_v2_Cluster_DnsLookupFamily = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * The hash function used to hash hosts onto the ketama ring.
 */
var _envoy_api_v2_Cluster_RingHashLbConfig_HashFunction;
(function (_envoy_api_v2_Cluster_RingHashLbConfig_HashFunction) {
    /**
     * Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
     */
    _envoy_api_v2_Cluster_RingHashLbConfig_HashFunction[_envoy_api_v2_Cluster_RingHashLbConfig_HashFunction["XX_HASH"] = 0] = "XX_HASH";
    /**
     * Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
     * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
     * on Linux and not macOS.
     */
    _envoy_api_v2_Cluster_RingHashLbConfig_HashFunction[_envoy_api_v2_Cluster_RingHashLbConfig_HashFunction["MURMUR_HASH_2"] = 1] = "MURMUR_HASH_2";
})(_envoy_api_v2_Cluster_RingHashLbConfig_HashFunction = exports._envoy_api_v2_Cluster_RingHashLbConfig_HashFunction || (exports._envoy_api_v2_Cluster_RingHashLbConfig_HashFunction = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 */
var _envoy_api_v2_Cluster_LbPolicy;
(function (_envoy_api_v2_Cluster_LbPolicy) {
    /**
     * Refer to the :ref:`round robin load balancing
     * policy<arch_overview_load_balancing_types_round_robin>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["ROUND_ROBIN"] = 0] = "ROUND_ROBIN";
    /**
     * Refer to the :ref:`least request load balancing
     * policy<arch_overview_load_balancing_types_least_request>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["LEAST_REQUEST"] = 1] = "LEAST_REQUEST";
    /**
     * Refer to the :ref:`ring hash load balancing
     * policy<arch_overview_load_balancing_types_ring_hash>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["RING_HASH"] = 2] = "RING_HASH";
    /**
     * Refer to the :ref:`random load balancing
     * policy<arch_overview_load_balancing_types_random>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["RANDOM"] = 3] = "RANDOM";
    /**
     * Refer to the :ref:`original destination load balancing
     * policy<arch_overview_load_balancing_types_original_destination>`
     * for an explanation.
     *
     * .. attention::
     *
     * **This load balancing policy is deprecated**. Use CLUSTER_PROVIDED instead.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["ORIGINAL_DST_LB"] = 4] = "ORIGINAL_DST_LB";
    /**
     * Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
     * for an explanation.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["MAGLEV"] = 5] = "MAGLEV";
    /**
     * This load balancer type must be specified if the configured cluster provides a cluster
     * specific load balancer. Consult the configured cluster's documentation for whether to set
     * this option or not.
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["CLUSTER_PROVIDED"] = 6] = "CLUSTER_PROVIDED";
    /**
     * [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
     * <envoy_api_field_Cluster.load_balancing_policy>` field to determine the LB policy.
     * [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
     * and instead using the new load_balancing_policy field as the one and only mechanism for
     * configuring this.]
     */
    _envoy_api_v2_Cluster_LbPolicy[_envoy_api_v2_Cluster_LbPolicy["LOAD_BALANCING_POLICY_CONFIG"] = 7] = "LOAD_BALANCING_POLICY_CONFIG";
})(_envoy_api_v2_Cluster_LbPolicy = exports._envoy_api_v2_Cluster_LbPolicy || (exports._envoy_api_v2_Cluster_LbPolicy = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 */
var _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy;
(function (_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) {
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["NO_FALLBACK"] = 0] = "NO_FALLBACK";
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["ANY_ENDPOINT"] = 1] = "ANY_ENDPOINT";
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy["DEFAULT_SUBSET"] = 2] = "DEFAULT_SUBSET";
})(_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy || (exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = {}));
// Original file: deps/envoy-api/envoy/api/v2/cluster.proto
/**
 * Allows to override top level fallback policy per selector.
 */
var _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;
(function (_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) {
    /**
     * If NOT_DEFINED top level config fallback policy is used instead.
     */
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["NOT_DEFINED"] = 0] = "NOT_DEFINED";
    /**
     * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
     */
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["NO_FALLBACK"] = 1] = "NO_FALLBACK";
    /**
     * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
     * (subject to policy, health checks, etc).
     */
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["ANY_ENDPOINT"] = 2] = "ANY_ENDPOINT";
    /**
     * If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     */
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["DEFAULT_SUBSET"] = 3] = "DEFAULT_SUBSET";
    /**
     * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
     * keys reduced to
     * :ref:`fallback_keys_subset<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
     * It allows for a fallback to a different, less specific selector if some of the keys of
     * the selector are considered optional.
     */
    _envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy[_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy["KEYS_SUBSET"] = 4] = "KEYS_SUBSET";
})(_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy || (exports._envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = {}));
//# sourceMappingURL=Cluster.js.map