"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = void 0;
const re2_wasm_1 = require("re2-wasm");
const xds_client_1 = require("./xds-client");
const grpc_js_1 = require("@grpc/grpc-js");
var uriToString = grpc_js_1.experimental.uriToString;
var registerResolver = grpc_js_1.experimental.registerResolver;
const load_balancer_cds_1 = require("./load-balancer-cds");
const load_balancer_xds_cluster_manager_1 = require("./load-balancer-xds-cluster-manager");
const matcher_1 = require("./matcher");
const route_action_1 = require("./route-action");
const TRACER_NAME = 'xds_resolver';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
// Better match type has smaller value.
var MatchType;
(function (MatchType) {
    MatchType[MatchType["EXACT_MATCH"] = 0] = "EXACT_MATCH";
    MatchType[MatchType["SUFFIX_MATCH"] = 1] = "SUFFIX_MATCH";
    MatchType[MatchType["PREFIX_MATCH"] = 2] = "PREFIX_MATCH";
    MatchType[MatchType["UNIVERSE_MATCH"] = 3] = "UNIVERSE_MATCH";
    MatchType[MatchType["INVALID_MATCH"] = 4] = "INVALID_MATCH";
})(MatchType || (MatchType = {}));
;
function domainPatternMatchType(domainPattern) {
    if (domainPattern.length === 0) {
        return MatchType.INVALID_MATCH;
    }
    if (domainPattern.indexOf('*') < 0) {
        return MatchType.EXACT_MATCH;
    }
    if (domainPattern === '*') {
        return MatchType.UNIVERSE_MATCH;
    }
    if (domainPattern.startsWith('*')) {
        return MatchType.SUFFIX_MATCH;
    }
    if (domainPattern.endsWith('*')) {
        return MatchType.PREFIX_MATCH;
    }
    return MatchType.INVALID_MATCH;
}
function domainMatch(matchType, domainPattern, expectedHostName) {
    switch (matchType) {
        case MatchType.EXACT_MATCH:
            return expectedHostName === domainPattern;
        case MatchType.SUFFIX_MATCH:
            return expectedHostName.endsWith(domainPattern.substring(1));
        case MatchType.PREFIX_MATCH:
            return expectedHostName.startsWith(domainPattern.substring(0, domainPattern.length - 1));
        case MatchType.UNIVERSE_MATCH:
            return true;
        case MatchType.INVALID_MATCH:
            return false;
    }
}
function findVirtualHostForDomain(virutalHostList, domain) {
    let targetVhost = null;
    let bestMatchType = MatchType.INVALID_MATCH;
    let longestMatch = 0;
    for (const virtualHost of virutalHostList) {
        for (const domainPattern of virtualHost.domains) {
            const matchType = domainPatternMatchType(domainPattern);
            // If we already have a match of a better type, skip this one
            if (matchType > bestMatchType) {
                continue;
            }
            // If we already have a longer match of the same type, skip this one
            if (matchType === bestMatchType && domainPattern.length <= longestMatch) {
                continue;
            }
            if (domainMatch(matchType, domainPattern, domain)) {
                targetVhost = virtualHost;
                bestMatchType = matchType;
                longestMatch = domainPattern.length;
            }
            if (bestMatchType === MatchType.EXACT_MATCH) {
                break;
            }
        }
        if (bestMatchType === MatchType.EXACT_MATCH) {
            break;
        }
    }
    return targetVhost;
}
const numberRegex = new re2_wasm_1.RE2(/^-?\d+$/u);
function getPredicateForHeaderMatcher(headerMatch) {
    let valueChecker;
    switch (headerMatch.header_match_specifier) {
        case 'exact_match':
            valueChecker = new matcher_1.ExactValueMatcher(headerMatch.exact_match);
            break;
        case 'safe_regex_match':
            valueChecker = new matcher_1.SafeRegexValueMatcher(headerMatch.safe_regex_match.regex);
            break;
        case 'range_match':
            const start = BigInt(headerMatch.range_match.start);
            const end = BigInt(headerMatch.range_match.end);
            valueChecker = new matcher_1.RangeValueMatcher(start, end);
            break;
        case 'present_match':
            valueChecker = new matcher_1.PresentValueMatcher();
            break;
        case 'prefix_match':
            valueChecker = new matcher_1.PrefixValueMatcher(headerMatch.prefix_match);
            break;
        case 'suffix_match':
            valueChecker = new matcher_1.SuffixValueMatcher(headerMatch.suffix_match);
            break;
        default:
            valueChecker = new matcher_1.RejectValueMatcher();
    }
    return new matcher_1.HeaderMatcher(headerMatch.name, valueChecker, headerMatch.invert_match);
}
const RUNTIME_FRACTION_DENOMINATOR_VALUES = {
    HUNDRED: 100,
    TEN_THOUSAND: 10000,
    MILLION: 1000000
};
function getPredicateForMatcher(routeMatch) {
    var _a, _b;
    let pathMatcher;
    const caseInsensitive = ((_a = routeMatch.case_sensitive) === null || _a === void 0 ? void 0 : _a.value) === false;
    switch (routeMatch.path_specifier) {
        case 'prefix':
            pathMatcher = new matcher_1.PathPrefixValueMatcher(routeMatch.prefix, caseInsensitive);
            break;
        case 'path':
            pathMatcher = new matcher_1.PathExactValueMatcher(routeMatch.path, caseInsensitive);
            break;
        case 'safe_regex':
            pathMatcher = new matcher_1.PathSafeRegexValueMatcher(routeMatch.safe_regex.regex, caseInsensitive);
            break;
        default:
            pathMatcher = new matcher_1.RejectValueMatcher();
    }
    const headerMatchers = routeMatch.headers.map(getPredicateForHeaderMatcher);
    let runtimeFraction;
    if (!((_b = routeMatch.runtime_fraction) === null || _b === void 0 ? void 0 : _b.default_value)) {
        runtimeFraction = null;
    }
    else {
        runtimeFraction = {
            numerator: routeMatch.runtime_fraction.default_value.numerator,
            denominator: RUNTIME_FRACTION_DENOMINATOR_VALUES[routeMatch.runtime_fraction.default_value.denominator]
        };
    }
    return new matcher_1.FullMatcher(pathMatcher, headerMatchers, runtimeFraction);
}
class XdsResolver {
    constructor(target, listener, channelOptions) {
        this.target = target;
        this.listener = listener;
        this.channelOptions = channelOptions;
        this.hasReportedSuccess = false;
        this.isLdsWatcherActive = false;
        /**
         * The latest route config name from an LDS response. The RDS watcher is
         * actively watching that name if and only if this is not null.
         */
        this.latestRouteConfigName = null;
        this.latestRouteConfig = null;
        this.clusterRefcounts = new Map();
        this.ldsWatcher = {
            onValidUpdate: (update) => {
                const httpConnectionManager = update.api_listener
                    .api_listener;
                switch (httpConnectionManager.route_specifier) {
                    case 'rds': {
                        const routeConfigName = httpConnectionManager.rds.route_config_name;
                        if (this.latestRouteConfigName !== routeConfigName) {
                            if (this.latestRouteConfigName !== null) {
                                xds_client_1.getSingletonXdsClient().removeRouteWatcher(this.latestRouteConfigName, this.rdsWatcher);
                            }
                            xds_client_1.getSingletonXdsClient().addRouteWatcher(httpConnectionManager.rds.route_config_name, this.rdsWatcher);
                            this.latestRouteConfigName = routeConfigName;
                        }
                        break;
                    }
                    case 'route_config':
                        if (this.latestRouteConfigName) {
                            xds_client_1.getSingletonXdsClient().removeRouteWatcher(this.latestRouteConfigName, this.rdsWatcher);
                        }
                        this.handleRouteConfig(httpConnectionManager.route_config);
                        break;
                    default:
                    // This is prevented by the validation rules
                }
            },
            onTransientError: (error) => {
                /* A transient error only needs to bubble up as a failure if we have
                 * not already provided a ServiceConfig for the upper layer to use */
                if (!this.hasReportedSuccess) {
                    trace('Resolution error for target ' + uriToString(this.target) + ' due to xDS client transient error ' + error.details);
                    this.reportResolutionError(error.details);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Resolution error for target ' + uriToString(this.target) + ': LDS resource does not exist');
                this.reportResolutionError(`Listener ${this.target} does not exist`);
            }
        };
        this.rdsWatcher = {
            onValidUpdate: (update) => {
                this.handleRouteConfig(update);
            },
            onTransientError: (error) => {
                /* A transient error only needs to bubble up as a failure if we have
                 * not already provided a ServiceConfig for the upper layer to use */
                if (!this.hasReportedSuccess) {
                    trace('Resolution error for target ' + uriToString(this.target) + ' due to xDS client transient error ' + error.details);
                    this.reportResolutionError(error.details);
                }
            },
            onResourceDoesNotExist: () => {
                trace('Resolution error for target ' + uriToString(this.target) + ' and route config ' + this.latestRouteConfigName + ': RDS resource does not exist');
                this.reportResolutionError(`Route config ${this.latestRouteConfigName} does not exist`);
            }
        };
    }
    refCluster(clusterName) {
        const refCount = this.clusterRefcounts.get(clusterName);
        if (refCount) {
            refCount.refCount += 1;
        }
    }
    unrefCluster(clusterName) {
        const refCount = this.clusterRefcounts.get(clusterName);
        if (refCount) {
            refCount.refCount -= 1;
            if (!refCount.inLastConfig && refCount.refCount === 0) {
                this.clusterRefcounts.delete(clusterName);
                this.handleRouteConfig(this.latestRouteConfig);
            }
        }
    }
    handleRouteConfig(routeConfig) {
        var _a, _b, _c, _d;
        this.latestRouteConfig = routeConfig;
        const virtualHost = findVirtualHostForDomain(routeConfig.virtual_hosts, this.target.path);
        if (virtualHost === null) {
            this.reportResolutionError('No matching route found');
            return;
        }
        trace('Received virtual host config ' + JSON.stringify(virtualHost, undefined, 2));
        const allConfigClusters = new Set();
        const matchList = [];
        for (const route of virtualHost.routes) {
            let routeAction;
            switch (route.route.cluster_specifier) {
                case 'cluster_header':
                    continue;
                case 'cluster': {
                    const cluster = route.route.cluster;
                    allConfigClusters.add(cluster);
                    routeAction = new route_action_1.SingleClusterRouteAction(cluster);
                    break;
                }
                case 'weighted_clusters': {
                    const weightedClusters = [];
                    for (const clusterWeight of route.route.weighted_clusters.clusters) {
                        allConfigClusters.add(clusterWeight.name);
                        weightedClusters.push({ name: clusterWeight.name, weight: (_b = (_a = clusterWeight.weight) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0 });
                    }
                    routeAction = new route_action_1.WeightedClusterRouteAction(weightedClusters, (_d = (_c = route.route.weighted_clusters.total_weight) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 100);
                }
            }
            const routeMatcher = getPredicateForMatcher(route.match);
            matchList.push({ matcher: routeMatcher, action: routeAction });
        }
        /* Mark clusters that are not in this route config, and remove ones with
          * no references */
        for (const [name, refCount] of Array.from(this.clusterRefcounts.entries())) {
            if (!allConfigClusters.has(name)) {
                refCount.inLastConfig = false;
                if (refCount.refCount === 0) {
                    this.clusterRefcounts.delete(name);
                }
            }
        }
        // Add any new clusters from this route config
        for (const name of allConfigClusters) {
            if (this.clusterRefcounts.has(name)) {
                this.clusterRefcounts.get(name).inLastConfig = true;
            }
            else {
                this.clusterRefcounts.set(name, { inLastConfig: true, refCount: 0 });
            }
        }
        const configSelector = (methodName, metadata) => {
            for (const { matcher, action } of matchList) {
                if (matcher.apply(methodName, metadata)) {
                    const clusterName = action.getCluster();
                    this.refCluster(clusterName);
                    const onCommitted = () => {
                        this.unrefCluster(clusterName);
                    };
                    return {
                        methodConfig: { name: [] },
                        onCommitted: onCommitted,
                        pickInformation: { cluster: clusterName },
                        status: grpc_js_1.status.OK
                    };
                }
            }
            return {
                methodConfig: { name: [] },
                // cluster won't be used here, but it's set because of some TypeScript weirdness
                pickInformation: { cluster: '' },
                status: grpc_js_1.status.UNAVAILABLE
            };
        };
        trace('Created ConfigSelector with configuration:');
        for (const { matcher, action } of matchList) {
            trace(matcher.toString());
            trace('=> ' + action.toString());
        }
        const clusterConfigMap = new Map();
        for (const clusterName of this.clusterRefcounts.keys()) {
            clusterConfigMap.set(clusterName, { child_policy: [new load_balancer_cds_1.CdsLoadBalancingConfig(clusterName)] });
        }
        const lbPolicyConfig = new load_balancer_xds_cluster_manager_1.XdsClusterManagerLoadBalancingConfig(clusterConfigMap);
        const serviceConfig = {
            methodConfig: [],
            loadBalancingConfig: [lbPolicyConfig]
        };
        this.listener.onSuccessfulResolution([], serviceConfig, null, configSelector, {});
    }
    reportResolutionError(reason) {
        this.listener.onError({
            code: grpc_js_1.status.UNAVAILABLE,
            details: `xDS name resolution failed for target ${uriToString(this.target)}: ${reason}`,
            metadata: new grpc_js_1.Metadata(),
        });
    }
    updateResolution() {
        // Wait until updateResolution is called once to start the xDS requests
        if (!this.isLdsWatcherActive) {
            trace('Starting resolution for target ' + uriToString(this.target));
            xds_client_1.getSingletonXdsClient().addListenerWatcher(this.target.path, this.ldsWatcher);
            this.isLdsWatcherActive = true;
        }
    }
    destroy() {
        xds_client_1.getSingletonXdsClient().removeListenerWatcher(this.target.path, this.ldsWatcher);
        if (this.latestRouteConfigName) {
            xds_client_1.getSingletonXdsClient().removeRouteWatcher(this.latestRouteConfigName, this.rdsWatcher);
        }
    }
    static getDefaultAuthority(target) {
        return target.path;
    }
}
function setup() {
    registerResolver('xds', XdsResolver);
}
exports.setup = setup;
//# sourceMappingURL=resolver-xds.js.map