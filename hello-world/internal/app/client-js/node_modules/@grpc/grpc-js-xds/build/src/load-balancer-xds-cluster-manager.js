"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.XdsClusterManagerLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js/");
var validateLoadBalancingConfig = grpc_js_1.experimental.validateLoadBalancingConfig;
var PickResultType = grpc_js_1.experimental.PickResultType;
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var QueuePicker = grpc_js_1.experimental.QueuePicker;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var getFirstUsableConfig = grpc_js_1.experimental.getFirstUsableConfig;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
const TRACER_NAME = 'xds_cluster_manager';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'xds_cluster_manager';
class XdsClusterManagerLoadBalancingConfig {
    constructor(children) {
        this.children = children;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    getChildren() {
        return this.children;
    }
    toJsonObject() {
        const childrenField = {};
        for (const [childName, childValue] of this.children.entries()) {
            childrenField[childName] = {
                child_policy: childValue.child_policy.map(policy => policy.toJsonObject())
            };
        }
        return {
            [TYPE_NAME]: {
                children: childrenField
            }
        };
    }
    static createFromJson(obj) {
        const childrenMap = new Map();
        if (!('children' in obj && obj.children !== null && typeof obj.children === 'object')) {
            throw new Error('xds_cluster_manager config must have a children map');
        }
        for (const key of obj.children) {
            const childObj = obj.children[key];
            if (!('child_policy' in childObj && Array.isArray(childObj.child_policy))) {
                throw new Error(`xds_cluster_manager child ${key} must have a child_policy array`);
            }
            const validatedChild = {
                child_policy: childObj.child_policy.map(validateLoadBalancingConfig)
            };
            childrenMap.set(key, validatedChild);
        }
        return new XdsClusterManagerLoadBalancingConfig(childrenMap);
    }
}
exports.XdsClusterManagerLoadBalancingConfig = XdsClusterManagerLoadBalancingConfig;
class XdsClusterManagerPicker {
    constructor(childPickers) {
        this.childPickers = childPickers;
    }
    pick(pickArgs) {
        var _a;
        /* extraPickInfo.cluster should be set for all calls by the config selector
         * corresponding to the service config that specified the use of this LB
         * policy. */
        const cluster = (_a = pickArgs.extraPickInfo.cluster) !== null && _a !== void 0 ? _a : '';
        if (this.childPickers.has(cluster)) {
            return this.childPickers.get(cluster).pick(pickArgs);
        }
        else {
            return {
                pickResultType: PickResultType.TRANSIENT_FAILURE,
                status: {
                    code: grpc_js_1.status.INTERNAL,
                    details: `Requested cluster ${cluster} not found`,
                    metadata: new grpc_js_1.Metadata(),
                },
                subchannel: null,
                extraFilterFactory: null,
                onCallStarted: null
            };
        }
    }
}
class XdsClusterManager {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.XdsClusterManagerChildImpl = class {
            constructor(parent, name) {
                this.parent = parent;
                this.name = name;
                this.connectivityState = grpc_js_1.connectivityState.IDLE;
                this.childBalancer = new ChildLoadBalancerHandler({
                    createSubchannel: (subchannelAddress, subchannelOptions) => {
                        return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelOptions);
                    },
                    updateState: (connectivityState, picker) => {
                        this.updateState(connectivityState, picker);
                    },
                    requestReresolution: () => {
                        this.parent.channelControlHelper.requestReresolution();
                    }
                });
                this.picker = new QueuePicker(this.childBalancer);
            }
            updateState(connectivityState, picker) {
                trace('Child ' + this.name + ' ' + grpc_js_1.connectivityState[this.connectivityState] + ' -> ' + grpc_js_1.connectivityState[connectivityState]);
                this.connectivityState = connectivityState;
                this.picker = picker;
                this.parent.updateState();
            }
            updateAddressList(addressList, lbConfig, attributes) {
                const childConfig = getFirstUsableConfig(lbConfig.child_policy);
                if (childConfig !== null) {
                    this.childBalancer.updateAddressList(addressList, childConfig, attributes);
                }
            }
            exitIdle() {
                this.childBalancer.exitIdle();
            }
            resetBackoff() {
                this.childBalancer.resetBackoff();
            }
            destroy() {
                this.childBalancer.destroy();
            }
            getConnectivityState() {
                return this.connectivityState;
            }
            getPicker() {
                return this.picker;
            }
        };
        // End of XdsClusterManagerChildImpl
        this.children = new Map();
        // Shutdown is a placeholder value that will never appear in normal operation.
        this.currentState = grpc_js_1.connectivityState.SHUTDOWN;
    }
    updateState() {
        const pickerMap = new Map();
        let anyReady = false;
        let anyConnecting = false;
        let anyIdle = false;
        for (const [name, child] of this.children.entries()) {
            pickerMap.set(name, child.getPicker());
            switch (child.getConnectivityState()) {
                case grpc_js_1.connectivityState.READY:
                    anyReady = true;
                    break;
                case grpc_js_1.connectivityState.CONNECTING:
                    anyConnecting = true;
                    break;
                case grpc_js_1.connectivityState.IDLE:
                    anyIdle = true;
                    break;
            }
        }
        let connectivityState;
        if (anyReady) {
            connectivityState = grpc_js_1.connectivityState.READY;
        }
        else if (anyConnecting) {
            connectivityState = grpc_js_1.connectivityState.CONNECTING;
        }
        else if (anyIdle) {
            connectivityState = grpc_js_1.connectivityState.IDLE;
        }
        else {
            connectivityState = grpc_js_1.connectivityState.TRANSIENT_FAILURE;
        }
        /* For each of the states CONNECTING, IDLE, and TRANSIENT_FAILURE, there is
         * exactly one corresponding picker, so if the state is one of those and
         * that does not change, no new information is provided by passing the
         * new state upward. */
        if (connectivityState === this.currentState && connectivityState !== grpc_js_1.connectivityState.READY) {
            return;
        }
        let picker;
        switch (connectivityState) {
            case grpc_js_1.connectivityState.READY:
                picker = new XdsClusterManagerPicker(pickerMap);
                break;
            case grpc_js_1.connectivityState.CONNECTING:
            case grpc_js_1.connectivityState.IDLE:
                picker = new QueuePicker(this);
                break;
            default:
                picker = new UnavailablePicker({
                    code: grpc_js_1.status.UNAVAILABLE,
                    details: 'xds_cluster_manager: all children report state TRANSIENT_FAILURE',
                    metadata: new grpc_js_1.Metadata()
                });
        }
        trace('Transitioning to ' +
            grpc_js_1.connectivityState[connectivityState]);
        this.channelControlHelper.updateState(connectivityState, picker);
    }
    updateAddressList(addressList, lbConfig, attributes) {
        if (!(lbConfig instanceof XdsClusterManagerLoadBalancingConfig)) {
            // Reject a config of the wrong type
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
            return;
        }
        trace('Received update with config: ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
        const configChildren = lbConfig.getChildren();
        // Delete children that are not in the new config
        const namesToRemove = [];
        for (const name of this.children.keys()) {
            if (!configChildren.has(name)) {
                namesToRemove.push(name);
            }
        }
        for (const name of namesToRemove) {
            this.children.get(name).destroy();
            this.children.delete(name);
        }
        // Add new children that were not in the previous config
        for (const [name, childConfig] of configChildren.entries()) {
            if (!this.children.has(name)) {
                const newChild = new this.XdsClusterManagerChildImpl(this, name);
                newChild.updateAddressList(addressList, childConfig, attributes);
                this.children.set(name, newChild);
            }
        }
        this.updateState();
    }
    exitIdle() {
        for (const child of this.children.values()) {
            child.exitIdle();
        }
    }
    resetBackoff() {
        for (const child of this.children.values()) {
            child.resetBackoff();
        }
    }
    destroy() {
        for (const child of this.children.values()) {
            child.destroy();
        }
        this.children.clear();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
function setup() {
    registerLoadBalancerType(TYPE_NAME, XdsClusterManager, XdsClusterManagerLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-xds-cluster-manager.js.map