"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.CdsLoadBalancer = exports.CdsLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_client_1 = require("./xds-client");
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
const load_balancer_eds_1 = require("./load-balancer-eds");
const TRACER_NAME = 'cds_balancer';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'cds';
class CdsLoadBalancingConfig {
    constructor(cluster) {
        this.cluster = cluster;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                cluster: this.cluster
            }
        };
    }
    getCluster() {
        return this.cluster;
    }
    static createFromJson(obj) {
        if ('cluster' in obj) {
            return new CdsLoadBalancingConfig(obj.cluster);
        }
        else {
            throw new Error('Missing "cluster" in cds load balancing config');
        }
    }
}
exports.CdsLoadBalancingConfig = CdsLoadBalancingConfig;
class CdsLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.isWatcherActive = false;
        this.latestCdsUpdate = null;
        this.latestConfig = null;
        this.latestAttributes = {};
        this.childBalancer = new ChildLoadBalancerHandler(channelControlHelper);
        this.watcher = {
            onValidUpdate: (update) => {
                var _a;
                this.latestCdsUpdate = update;
                /* the lrs_server.self field indicates that the same server should be
                 * used for load reporting as for other xDS operations. Setting
                 * lrsLoadReportingServerName to the empty string sets that behavior.
                 * Otherwise, if the field is omitted, load reporting is disabled. */
                const edsConfig = new load_balancer_eds_1.EdsLoadBalancingConfig(update.name, [], [], update.eds_cluster_config.service_name === '' ? undefined : update.eds_cluster_config.service_name, ((_a = update.lrs_server) === null || _a === void 0 ? void 0 : _a.self) ? '' : undefined);
                trace('Child update EDS config: ' + JSON.stringify(edsConfig));
                this.childBalancer.updateAddressList([], edsConfig, this.latestAttributes);
            },
            onResourceDoesNotExist: () => {
                this.isWatcherActive = false;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: 'CDS resource does not exist', metadata: new grpc_js_1.Metadata() }));
                this.childBalancer.destroy();
            },
            onTransientError: (statusObj) => {
                if (this.latestCdsUpdate === null) {
                    channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({
                        code: grpc_js_1.status.UNAVAILABLE,
                        details: `xDS request failed with error ${statusObj.details}`,
                        metadata: new grpc_js_1.Metadata(),
                    }));
                }
            },
        };
    }
    updateAddressList(addressList, lbConfig, attributes) {
        var _a;
        if (!(lbConfig instanceof CdsLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        trace('Received update with config ' + JSON.stringify(lbConfig, undefined, 2));
        this.latestAttributes = attributes;
        /* If the cluster is changing, disable the old watcher before adding the new
         * one */
        if (this.isWatcherActive &&
            ((_a = this.latestConfig) === null || _a === void 0 ? void 0 : _a.getCluster()) !== lbConfig.getCluster()) {
            trace('Removing old cluster watcher for cluster name ' + this.latestConfig.getCluster());
            xds_client_1.getSingletonXdsClient().removeClusterWatcher(this.latestConfig.getCluster(), this.watcher);
            /* Setting isWatcherActive to false here lets us have one code path for
             * calling addClusterWatcher */
            this.isWatcherActive = false;
            /* If we have a new name, the latestCdsUpdate does not correspond to
             * the new config, so it is no longer valid */
            this.latestCdsUpdate = null;
        }
        this.latestConfig = lbConfig;
        if (!this.isWatcherActive) {
            trace('Adding new cluster watcher for cluster name ' + lbConfig.getCluster());
            xds_client_1.getSingletonXdsClient().addClusterWatcher(lbConfig.getCluster(), this.watcher);
            this.isWatcherActive = true;
        }
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        var _a;
        trace('Destroying load balancer with cluster name ' + ((_a = this.latestConfig) === null || _a === void 0 ? void 0 : _a.getCluster()));
        this.childBalancer.destroy();
        if (this.isWatcherActive) {
            xds_client_1.getSingletonXdsClient().removeClusterWatcher(this.latestConfig.getCluster(), this.watcher);
        }
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.CdsLoadBalancer = CdsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, CdsLoadBalancer, CdsLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-cds.js.map