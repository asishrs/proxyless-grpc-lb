"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdsState = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const net_1 = require("net");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
class EdsState {
    constructor(updateResourceNames) {
        this.updateResourceNames = updateResourceNames;
        this.versionInfo = '';
        this.nonce = '';
        this.watchers = new Map();
        this.latestResponses = [];
    }
    /**
     * Add the watcher to the watcher list. Returns true if the list of resource
     * names has changed, and false otherwise.
     * @param edsServiceName
     * @param watcher
     */
    addWatcher(edsServiceName, watcher) {
        let watchersEntry = this.watchers.get(edsServiceName);
        let addedServiceName = false;
        if (watchersEntry === undefined) {
            addedServiceName = true;
            watchersEntry = [];
            this.watchers.set(edsServiceName, watchersEntry);
        }
        trace('Adding EDS watcher (' + watchersEntry.length + ' ->' + (watchersEntry.length + 1) + ') for edsServiceName ' + edsServiceName);
        watchersEntry.push(watcher);
        /* If we have already received an update for the requested edsServiceName,
         * immediately pass that update along to the watcher */
        for (const message of this.latestResponses) {
            if (message.cluster_name === edsServiceName) {
                /* These updates normally occur asynchronously, so we ensure that
                 * the same happens here */
                process.nextTick(() => {
                    trace('Reporting existing EDS update for new watcher for edsServiceName ' + edsServiceName);
                    watcher.onValidUpdate(message);
                });
            }
        }
        if (addedServiceName) {
            this.updateResourceNames();
        }
    }
    removeWatcher(edsServiceName, watcher) {
        trace('Removing EDS watcher for edsServiceName ' + edsServiceName);
        const watchersEntry = this.watchers.get(edsServiceName);
        let removedServiceName = false;
        if (watchersEntry !== undefined) {
            const entryIndex = watchersEntry.indexOf(watcher);
            if (entryIndex >= 0) {
                trace('Removed EDS watcher (' + watchersEntry.length + ' -> ' + (watchersEntry.length - 1) + ') for edsServiceName ' + edsServiceName);
                watchersEntry.splice(entryIndex, 1);
            }
            if (watchersEntry.length === 0) {
                removedServiceName = true;
                this.watchers.delete(edsServiceName);
            }
        }
        if (removedServiceName) {
            this.updateResourceNames();
        }
    }
    getResourceNames() {
        return Array.from(this.watchers.keys());
    }
    /**
     * Validate the ClusterLoadAssignment object by these rules:
     * https://github.com/grpc/proposal/blob/master/A27-xds-global-load-balancing.md#clusterloadassignment-proto
     * @param message
     */
    validateResponse(message) {
        var _a, _b;
        for (const endpoint of message.endpoints) {
            for (const lb of endpoint.lb_endpoints) {
                const socketAddress = (_b = (_a = lb.endpoint) === null || _a === void 0 ? void 0 : _a.address) === null || _b === void 0 ? void 0 : _b.socket_address;
                if (!socketAddress) {
                    return false;
                }
                if (socketAddress.port_specifier !== 'port_value') {
                    return false;
                }
                if (!(net_1.isIPv4(socketAddress.address) || net_1.isIPv6(socketAddress.address))) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Given a list of edsServiceNames (which may actually be the cluster name),
     * for each watcher watching a name not on the list, call that watcher's
     * onResourceDoesNotExist method.
     * @param allClusterNames
     */
    handleMissingNames(allEdsServiceNames) {
        for (const [edsServiceName, watcherList] of this.watchers.entries()) {
            if (!allEdsServiceNames.has(edsServiceName)) {
                trace('Reporting EDS resource does not exist for edsServiceName ' + edsServiceName);
                for (const watcher of watcherList) {
                    watcher.onResourceDoesNotExist();
                }
            }
        }
    }
    handleResponses(responses) {
        var _a;
        for (const message of responses) {
            if (!this.validateResponse(message)) {
                trace('EDS validation failed for message ' + JSON.stringify(message));
                return 'EDS Error: ClusterLoadAssignment validation failed';
            }
        }
        this.latestResponses = responses;
        const allClusterNames = new Set();
        for (const message of responses) {
            allClusterNames.add(message.cluster_name);
            const watchers = (_a = this.watchers.get(message.cluster_name)) !== null && _a !== void 0 ? _a : [];
            for (const watcher of watchers) {
                watcher.onValidUpdate(message);
            }
        }
        trace('Received EDS updates for cluster names ' + Array.from(allClusterNames));
        this.handleMissingNames(allClusterNames);
        return null;
    }
    reportStreamError(status) {
        for (const watcherList of this.watchers.values()) {
            for (const watcher of watcherList) {
                watcher.onTransientError(status);
            }
        }
    }
}
exports.EdsState = EdsState;
//# sourceMappingURL=eds-state.js.map