"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSingletonXdsClient = exports.XdsClient = void 0;
const protoLoader = require("@grpc/proto-loader");
const grpc_js_1 = require("@grpc/grpc-js");
const xds_bootstrap_1 = require("./xds-bootstrap");
var BackoffTimeout = grpc_js_1.experimental.BackoffTimeout;
const google_default_credentials_1 = require("./google-default-credentials");
const eds_state_1 = require("./xds-stream-state/eds-state");
const cds_state_1 = require("./xds-stream-state/cds-state");
const rds_state_1 = require("./xds-stream-state/rds-state");
const lds_state_1 = require("./xds-stream-state/lds-state");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const clientVersion = require('../../package.json').version;
const EDS_TYPE_URL = 'type.googleapis.com/envoy.api.v2.ClusterLoadAssignment';
const CDS_TYPE_URL = 'type.googleapis.com/envoy.api.v2.Cluster';
const LDS_TYPE_URL = 'type.googleapis.com/envoy.api.v2.Listener';
const RDS_TYPE_URL = 'type.googleapis.com/envoy.api.v2.RouteConfiguration';
const HTTP_CONNECTION_MANGER_TYPE_URL = 'type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager';
let loadedProtos = null;
function loadAdsProtos() {
    if (loadedProtos !== null) {
        return loadedProtos;
    }
    loadedProtos = protoLoader
        .load([
        'envoy/service/discovery/v2/ads.proto',
        'envoy/service/load_stats/v2/lrs.proto',
        'envoy/api/v2/listener.proto',
        'envoy/api/v2/route.proto',
        'envoy/api/v2/cluster.proto',
        'envoy/api/v2/endpoint.proto',
        'envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto',
    ], {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        json: true,
        includeDirs: [
            // Paths are relative to src/build
            __dirname + '/../../deps/envoy-api/',
            __dirname + '/../../deps/udpa/',
            __dirname + '/../../deps/googleapis/',
            __dirname + '/../../deps/protoc-gen-validate/',
        ],
    })
        .then((packageDefinition) => grpc_js_1.loadPackageDefinition(packageDefinition));
    return loadedProtos;
}
function localityEqual(loc1, loc2) {
    return (loc1.region === loc2.region &&
        loc1.zone === loc2.zone &&
        loc1.sub_zone === loc2.sub_zone);
}
class ClusterLoadReportMap {
    constructor() {
        this.statsMap = [];
    }
    get(clusterName, edsServiceName) {
        for (const statsObj of this.statsMap) {
            if (statsObj.clusterName === clusterName &&
                statsObj.edsServiceName === edsServiceName) {
                return statsObj.stats;
            }
        }
        return undefined;
    }
    getOrCreate(clusterName, edsServiceName) {
        for (const statsObj of this.statsMap) {
            if (statsObj.clusterName === clusterName &&
                statsObj.edsServiceName === edsServiceName) {
                return statsObj.stats;
            }
        }
        const newStats = {
            callsDropped: new Map(),
            localityStats: [],
            intervalStart: process.hrtime(),
        };
        this.statsMap.push({
            clusterName,
            edsServiceName,
            stats: newStats,
        });
        return newStats;
    }
    *entries() {
        for (const statsEntry of this.statsMap) {
            yield [
                {
                    clusterName: statsEntry.clusterName,
                    edsServiceName: statsEntry.edsServiceName,
                },
                statsEntry.stats,
            ];
        }
    }
}
function getResponseMessages(typeUrl, resources) {
    const result = [];
    for (const resource of resources) {
        if (protoLoader.isAnyExtension(resource) && resource['@type'] === typeUrl) {
            result.push(resource);
        }
        else {
            throw new Error(`ADS Error: Invalid resource type ${protoLoader.isAnyExtension(resource)
                ? resource['@type']
                : resource.type_url}, expected ${typeUrl}`);
        }
    }
    return result;
}
class XdsClient {
    constructor() {
        this.adsNode = null;
        this.adsClient = null;
        this.adsCall = null;
        this.lrsNode = null;
        this.lrsClient = null;
        this.lrsCall = null;
        this.latestLrsSettings = null;
        this.clusterStatsMap = new ClusterLoadReportMap();
        this.hasShutdown = false;
        const edsState = new eds_state_1.EdsState(() => {
            this.updateNames(EDS_TYPE_URL);
        });
        const cdsState = new cds_state_1.CdsState(edsState, () => {
            this.updateNames(CDS_TYPE_URL);
        });
        const rdsState = new rds_state_1.RdsState(() => {
            this.updateNames(RDS_TYPE_URL);
        });
        const ldsState = new lds_state_1.LdsState(rdsState, () => {
            this.updateNames(LDS_TYPE_URL);
        });
        this.adsState = {
            [EDS_TYPE_URL]: edsState,
            [CDS_TYPE_URL]: cdsState,
            [RDS_TYPE_URL]: rdsState,
            [LDS_TYPE_URL]: ldsState,
        };
        const channelArgs = {
            // 5 minutes
            'grpc.keepalive_time_ms': 5 * 60 * 1000
        };
        this.adsBackoff = new BackoffTimeout(() => {
            this.maybeStartAdsStream();
        });
        this.adsBackoff.unref();
        this.lrsBackoff = new BackoffTimeout(() => {
            this.maybeStartLrsStream();
        });
        this.lrsBackoff.unref();
        Promise.all([xds_bootstrap_1.loadBootstrapInfo(), loadAdsProtos()]).then(([bootstrapInfo, protoDefinitions]) => {
            if (this.hasShutdown) {
                return;
            }
            const node = Object.assign(Object.assign({}, bootstrapInfo.node), { build_version: `gRPC Node Pure JS ${clientVersion}`, user_agent_name: 'gRPC Node Pure JS' });
            this.adsNode = Object.assign(Object.assign({}, node), { client_features: ['envoy.lb.does_not_support_overprovisioning'] });
            this.lrsNode = Object.assign(Object.assign({}, node), { client_features: ['envoy.lrs.supports_send_all_clusters'] });
            const credentialsConfigs = bootstrapInfo.xdsServers[0].channelCreds;
            let channelCreds = null;
            for (const config of credentialsConfigs) {
                if (config.type === 'google_default') {
                    channelCreds = google_default_credentials_1.createGoogleDefaultCredentials();
                    break;
                }
                else if (config.type === 'insecure') {
                    channelCreds = grpc_js_1.ChannelCredentials.createInsecure();
                    break;
                }
            }
            if (channelCreds === null) {
                trace('Failed to initialize xDS Client. No valid credentials types found.');
                // Bubble this error up to any listeners
                this.reportStreamError({
                    code: grpc_js_1.status.INTERNAL,
                    details: 'Failed to initialize xDS Client. No valid credentials types found.',
                    metadata: new grpc_js_1.Metadata(),
                });
                return;
            }
            trace('Starting xDS client connected to server URI ' + bootstrapInfo.xdsServers[0].serverUri);
            this.adsClient = new protoDefinitions.envoy.service.discovery.v2.AggregatedDiscoveryService(bootstrapInfo.xdsServers[0].serverUri, channelCreds, channelArgs);
            this.maybeStartAdsStream();
            this.lrsClient = new protoDefinitions.envoy.service.load_stats.v2.LoadReportingService(bootstrapInfo.xdsServers[0].serverUri, channelCreds, { channelOverride: this.adsClient.getChannel() });
            this.maybeStartLrsStream();
        }, (error) => {
            trace('Failed to initialize xDS Client. ' + error.message);
            // Bubble this error up to any listeners
            this.reportStreamError({
                code: grpc_js_1.status.INTERNAL,
                details: `Failed to initialize xDS Client. ${error.message}`,
                metadata: new grpc_js_1.Metadata(),
            });
        });
        this.statsTimer = setInterval(() => { }, 0);
        clearInterval(this.statsTimer);
    }
    handleAdsResponse(message) {
        let errorString;
        /* The cases in this switch statement look redundant but separating them
         * out like this is necessary for the typechecker to validate the types
         * as narrowly as we need it to. */
        switch (message.type_url) {
            case EDS_TYPE_URL:
                errorString = this.adsState[message.type_url].handleResponses(getResponseMessages(message.type_url, message.resources));
                break;
            case CDS_TYPE_URL:
                errorString = this.adsState[message.type_url].handleResponses(getResponseMessages(message.type_url, message.resources));
                break;
            case RDS_TYPE_URL:
                errorString = this.adsState[message.type_url].handleResponses(getResponseMessages(message.type_url, message.resources));
                break;
            case LDS_TYPE_URL:
                errorString = this.adsState[message.type_url].handleResponses(getResponseMessages(message.type_url, message.resources));
                break;
            default:
                errorString = `Unknown type_url ${message.type_url}`;
        }
        if (errorString === null) {
            trace('Acking message with type URL ' + message.type_url);
            /* errorString can only be null in one of the first 4 cases, which
             * implies that message.type_url is one of the 4 known type URLs, which
             * means that this type assertion is valid. */
            const typeUrl = message.type_url;
            this.adsState[typeUrl].nonce = message.nonce;
            this.adsState[typeUrl].versionInfo = message.version_info;
            this.ack(typeUrl);
        }
        else {
            trace('Nacking message with type URL ' + message.type_url + ': "' + errorString + '"');
            this.nack(message.type_url, errorString);
        }
    }
    /**
     * Start the ADS stream if the client exists and there is not already an
     * existing stream, and there
     */
    maybeStartAdsStream() {
        if (this.adsClient === null) {
            return;
        }
        if (this.adsCall !== null) {
            return;
        }
        if (this.hasShutdown) {
            return;
        }
        if (this.adsState[EDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[CDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[RDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[LDS_TYPE_URL].getResourceNames().length === 0) {
            return;
        }
        trace('Starting ADS stream');
        // Backoff relative to when we start the request
        this.adsBackoff.runOnce();
        this.adsCall = this.adsClient.StreamAggregatedResources();
        this.adsCall.on('data', (message) => {
            this.handleAdsResponse(message);
        });
        this.adsCall.on('error', (error) => {
            trace('ADS stream ended. code=' + error.code + ' details= ' + error.details);
            this.adsCall = null;
            this.reportStreamError(error);
            /* If the backoff timer is no longer running, we do not need to wait any
             * more to start the new call. */
            if (!this.adsBackoff.isRunning()) {
                this.maybeStartAdsStream();
            }
        });
        const allTypeUrls = [
            EDS_TYPE_URL,
            CDS_TYPE_URL,
            RDS_TYPE_URL,
            LDS_TYPE_URL,
        ];
        for (const typeUrl of allTypeUrls) {
            const state = this.adsState[typeUrl];
            if (state.getResourceNames().length > 0) {
                this.updateNames(typeUrl);
            }
        }
    }
    /**
     * Acknowledge an update. This should be called after the local nonce and
     * version info are updated so that it sends the post-update values.
     */
    ack(typeUrl) {
        /* An ack is the best indication of a successful interaction between the
         * client and the server, so we can reset the backoff timer here. */
        this.adsBackoff.stop();
        this.adsBackoff.reset();
        this.updateNames(typeUrl);
    }
    /**
     * Reject an update. This should be called without updating the local
     * nonce and version info.
     */
    nack(typeUrl, message) {
        var _a;
        let resourceNames;
        let nonce;
        let versionInfo;
        switch (typeUrl) {
            case EDS_TYPE_URL:
            case CDS_TYPE_URL:
            case RDS_TYPE_URL:
            case LDS_TYPE_URL:
                resourceNames = this.adsState[typeUrl].getResourceNames();
                nonce = this.adsState[typeUrl].nonce;
                versionInfo = this.adsState[typeUrl].versionInfo;
                break;
            default:
                resourceNames = [];
                nonce = '';
                versionInfo = '';
        }
        (_a = this.adsCall) === null || _a === void 0 ? void 0 : _a.write({
            node: this.adsNode,
            type_url: typeUrl,
            resource_names: resourceNames,
            response_nonce: nonce,
            version_info: versionInfo,
            error_detail: {
                message: message,
            },
        });
    }
    updateNames(typeUrl) {
        var _a, _b, _c;
        if (this.adsState[EDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[CDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[RDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[LDS_TYPE_URL].getResourceNames().length === 0) {
            (_a = this.adsCall) === null || _a === void 0 ? void 0 : _a.end();
            (_b = this.lrsCall) === null || _b === void 0 ? void 0 : _b.end();
            return;
        }
        this.maybeStartAdsStream();
        this.maybeStartLrsStream();
        trace('Sending update for type URL ' + typeUrl + ' with names ' + this.adsState[typeUrl].getResourceNames());
        (_c = this.adsCall) === null || _c === void 0 ? void 0 : _c.write({
            node: this.adsNode,
            type_url: typeUrl,
            resource_names: this.adsState[typeUrl].getResourceNames(),
            response_nonce: this.adsState[typeUrl].nonce,
            version_info: this.adsState[typeUrl].versionInfo,
        });
    }
    reportStreamError(status) {
        this.adsState[EDS_TYPE_URL].reportStreamError(status);
        this.adsState[CDS_TYPE_URL].reportStreamError(status);
        this.adsState[RDS_TYPE_URL].reportStreamError(status);
        this.adsState[LDS_TYPE_URL].reportStreamError(status);
    }
    maybeStartLrsStream() {
        if (!this.lrsClient) {
            return;
        }
        if (this.lrsCall) {
            return;
        }
        if (this.hasShutdown) {
            return;
        }
        if (this.adsState[EDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[CDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[RDS_TYPE_URL].getResourceNames().length === 0 &&
            this.adsState[LDS_TYPE_URL].getResourceNames().length === 0) {
            return;
        }
        trace('Starting LRS stream');
        this.lrsBackoff.runOnce();
        this.lrsCall = this.lrsClient.streamLoadStats();
        let receivedSettingsForThisStream = false;
        this.lrsCall.on('data', (message) => {
            var _a, _b, _c, _d, _e, _f;
            /* Once we get any response from the server, we assume that the stream is
             * in a good state, so we can reset the backoff timer. */
            this.lrsBackoff.stop();
            this.lrsBackoff.reset();
            if (!receivedSettingsForThisStream ||
                ((_a = message.load_reporting_interval) === null || _a === void 0 ? void 0 : _a.seconds) !== ((_c = (_b = this.latestLrsSettings) === null || _b === void 0 ? void 0 : _b.load_reporting_interval) === null || _c === void 0 ? void 0 : _c.seconds) ||
                ((_d = message.load_reporting_interval) === null || _d === void 0 ? void 0 : _d.nanos) !== ((_f = (_e = this.latestLrsSettings) === null || _e === void 0 ? void 0 : _e.load_reporting_interval) === null || _f === void 0 ? void 0 : _f.nanos)) {
                /* Only reset the timer if the interval has changed or was not set
                 * before. */
                clearInterval(this.statsTimer);
                /* Convert a google.protobuf.Duration to a number of milliseconds for
                 * use with setInterval. */
                const loadReportingIntervalMs = Number.parseInt(message.load_reporting_interval.seconds) * 1000 +
                    message.load_reporting_interval.nanos / 1000000;
                trace('Received LRS request with load reporting interval ' + loadReportingIntervalMs + ' ms');
                this.statsTimer = setInterval(() => {
                    this.sendStats();
                }, loadReportingIntervalMs);
            }
            this.latestLrsSettings = message;
            receivedSettingsForThisStream = true;
        });
        this.lrsCall.on('error', (error) => {
            trace('LRS stream ended. code=' + error.code + ' details= ' + error.details);
            this.lrsCall = null;
            clearInterval(this.statsTimer);
            /* If the backoff timer is no longer running, we do not need to wait any
             * more to start the new call. */
            if (!this.lrsBackoff.isRunning()) {
                this.maybeStartLrsStream();
            }
        });
        /* Send buffered stats information when starting LRS stream. If there is no
         * buffered stats information, it will still send the node field. */
        this.sendStats();
    }
    sendStats() {
        if (!this.lrsCall) {
            return;
        }
        if (!this.latestLrsSettings) {
            this.lrsCall.write({
                node: this.lrsNode,
            });
            return;
        }
        const clusterStats = [];
        for (const [{ clusterName, edsServiceName }, stats,] of this.clusterStatsMap.entries()) {
            if (this.latestLrsSettings.send_all_clusters ||
                this.latestLrsSettings.clusters.indexOf(clusterName) > 0) {
                const upstreamLocalityStats = [];
                for (const localityStats of stats.localityStats) {
                    // Skip localities with 0 requests
                    if (localityStats.callsStarted > 0 ||
                        localityStats.callsSucceeded > 0 ||
                        localityStats.callsFailed > 0) {
                        upstreamLocalityStats.push({
                            locality: localityStats.locality,
                            total_issued_requests: localityStats.callsStarted,
                            total_successful_requests: localityStats.callsSucceeded,
                            total_error_requests: localityStats.callsFailed,
                            total_requests_in_progress: localityStats.callsInProgress,
                        });
                        localityStats.callsStarted = 0;
                        localityStats.callsSucceeded = 0;
                        localityStats.callsFailed = 0;
                    }
                }
                const droppedRequests = [];
                let totalDroppedRequests = 0;
                for (const [category, count] of stats.callsDropped.entries()) {
                    if (count > 0) {
                        droppedRequests.push({
                            category,
                            dropped_count: count,
                        });
                        totalDroppedRequests += count;
                    }
                }
                // Clear out dropped call stats after sending them
                stats.callsDropped.clear();
                const interval = process.hrtime(stats.intervalStart);
                stats.intervalStart = process.hrtime();
                // Skip clusters with 0 requests
                if (upstreamLocalityStats.length > 0 || totalDroppedRequests > 0) {
                    clusterStats.push({
                        cluster_name: clusterName,
                        cluster_service_name: edsServiceName,
                        dropped_requests: droppedRequests,
                        total_dropped_requests: totalDroppedRequests,
                        upstream_locality_stats: upstreamLocalityStats,
                        load_report_interval: {
                            seconds: interval[0],
                            nanos: interval[1],
                        },
                    });
                }
            }
        }
        trace('Sending LRS stats ' + JSON.stringify(clusterStats, undefined, 2));
        this.lrsCall.write({
            node: this.lrsNode,
            cluster_stats: clusterStats,
        });
    }
    addEndpointWatcher(edsServiceName, watcher) {
        trace('Watcher added for endpoint ' + edsServiceName);
        this.adsState[EDS_TYPE_URL].addWatcher(edsServiceName, watcher);
    }
    removeEndpointWatcher(edsServiceName, watcher) {
        trace('Watcher removed for endpoint ' + edsServiceName);
        this.adsState[EDS_TYPE_URL].removeWatcher(edsServiceName, watcher);
    }
    addClusterWatcher(clusterName, watcher) {
        trace('Watcher added for cluster ' + clusterName);
        this.adsState[CDS_TYPE_URL].addWatcher(clusterName, watcher);
    }
    removeClusterWatcher(clusterName, watcher) {
        trace('Watcher removed for cluster ' + clusterName);
        this.adsState[CDS_TYPE_URL].removeWatcher(clusterName, watcher);
    }
    addRouteWatcher(routeConfigName, watcher) {
        trace('Watcher added for route ' + routeConfigName);
        this.adsState[RDS_TYPE_URL].addWatcher(routeConfigName, watcher);
    }
    removeRouteWatcher(routeConfigName, watcher) {
        trace('Watcher removed for route ' + routeConfigName);
        this.adsState[RDS_TYPE_URL].removeWatcher(routeConfigName, watcher);
    }
    addListenerWatcher(targetName, watcher) {
        trace('Watcher added for listener ' + targetName);
        this.adsState[LDS_TYPE_URL].addWatcher(targetName, watcher);
    }
    removeListenerWatcher(targetName, watcher) {
        trace('Watcher removed for listener ' + targetName);
        this.adsState[LDS_TYPE_URL].removeWatcher(targetName, watcher);
    }
    /**
     *
     * @param lrsServer The target name of the server to send stats to. An empty
     *     string indicates that the default LRS client should be used. Currently
     *     only the empty string is supported here.
     * @param clusterName
     * @param edsServiceName
     */
    addClusterDropStats(lrsServer, clusterName, edsServiceName) {
        trace('addClusterDropStats(lrsServer=' + lrsServer + ', clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ')');
        if (lrsServer !== '') {
            return {
                addCallDropped: (category) => { },
            };
        }
        const clusterStats = this.clusterStatsMap.getOrCreate(clusterName, edsServiceName);
        return {
            addCallDropped: (category) => {
                var _a;
                const prevCount = (_a = clusterStats.callsDropped.get(category)) !== null && _a !== void 0 ? _a : 0;
                clusterStats.callsDropped.set(category, prevCount + 1);
            },
        };
    }
    addClusterLocalityStats(lrsServer, clusterName, edsServiceName, locality) {
        trace('addClusterLocalityStats(lrsServer=' + lrsServer + ', clusterName=' + clusterName + ', edsServiceName=' + edsServiceName + ', locality=' + JSON.stringify(locality) + ')');
        if (lrsServer !== '') {
            return {
                addCallStarted: () => { },
                addCallFinished: (fail) => { },
            };
        }
        const clusterStats = this.clusterStatsMap.getOrCreate(clusterName, edsServiceName);
        let localityStats = null;
        for (const statsObj of clusterStats.localityStats) {
            if (localityEqual(locality, statsObj.locality)) {
                localityStats = statsObj;
                break;
            }
        }
        if (localityStats === null) {
            localityStats = {
                locality: locality,
                callsInProgress: 0,
                callsStarted: 0,
                callsSucceeded: 0,
                callsFailed: 0,
            };
            clusterStats.localityStats.push(localityStats);
        }
        /* Help the compiler understand that this object is always non-null in the
         * closure */
        const finalLocalityStats = localityStats;
        return {
            addCallStarted: () => {
                finalLocalityStats.callsStarted += 1;
                finalLocalityStats.callsInProgress += 1;
            },
            addCallFinished: (fail) => {
                if (fail) {
                    finalLocalityStats.callsFailed += 1;
                }
                else {
                    finalLocalityStats.callsSucceeded += 1;
                }
                finalLocalityStats.callsInProgress -= 1;
            },
        };
    }
    shutdown() {
        var _a, _b, _c, _d;
        (_a = this.adsCall) === null || _a === void 0 ? void 0 : _a.cancel();
        (_b = this.adsClient) === null || _b === void 0 ? void 0 : _b.close();
        (_c = this.lrsCall) === null || _c === void 0 ? void 0 : _c.cancel();
        (_d = this.lrsClient) === null || _d === void 0 ? void 0 : _d.close();
        this.hasShutdown = true;
    }
}
exports.XdsClient = XdsClient;
let singletonXdsClient = null;
function getSingletonXdsClient() {
    if (singletonXdsClient === null) {
        singletonXdsClient = new XdsClient();
    }
    return singletonXdsClient;
}
exports.getSingletonXdsClient = getSingletonXdsClient;
//# sourceMappingURL=xds-client.js.map