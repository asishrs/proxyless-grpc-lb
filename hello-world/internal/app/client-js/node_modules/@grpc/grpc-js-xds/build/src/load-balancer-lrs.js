"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = exports.LrsLoadBalancer = exports.LrsLoadBalancingConfig = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_client_1 = require("./xds-client");
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var getFirstUsableConfig = grpc_js_1.experimental.getFirstUsableConfig;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var PickResultType = grpc_js_1.experimental.PickResultType;
var BaseFilter = grpc_js_1.experimental.BaseFilter;
var FilterStackFactory = grpc_js_1.experimental.FilterStackFactory;
var validateLoadBalancingConfig = grpc_js_1.experimental.validateLoadBalancingConfig;
const TYPE_NAME = 'lrs';
class LrsLoadBalancingConfig {
    constructor(clusterName, edsServiceName, lrsLoadReportingServerName, locality, childPolicy) {
        this.clusterName = clusterName;
        this.edsServiceName = edsServiceName;
        this.lrsLoadReportingServerName = lrsLoadReportingServerName;
        this.locality = locality;
        this.childPolicy = childPolicy;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                cluster_name: this.clusterName,
                eds_service_name: this.edsServiceName,
                lrs_load_reporting_server_name: this.lrsLoadReportingServerName,
                locality: this.locality,
                child_policy: this.childPolicy.map(policy => policy.toJsonObject())
            }
        };
    }
    getClusterName() {
        return this.clusterName;
    }
    getEdsServiceName() {
        return this.edsServiceName;
    }
    getLrsLoadReportingServerName() {
        return this.lrsLoadReportingServerName;
    }
    getLocality() {
        return this.locality;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        var _a, _b, _c;
        if (!('cluster_name' in obj && typeof obj.cluster_name === 'string')) {
            throw new Error('lrs config must have a string field cluster_name');
        }
        if (!('eds_service_name' in obj && typeof obj.eds_service_name === 'string')) {
            throw new Error('lrs config must have a string field eds_service_name');
        }
        if (!('lrs_load_reporting_server_name' in obj && typeof obj.lrs_load_reporting_server_name === 'string')) {
            throw new Error('lrs config must have a string field lrs_load_reporting_server_name');
        }
        if (!('locality' in obj && obj.locality !== null && typeof obj.locality === 'object')) {
            throw new Error('lrs config must have an object field locality');
        }
        if ('region' in obj.locality && typeof obj.locality.region !== 'string') {
            throw new Error('lrs config locality.region field must be a string if provided');
        }
        if ('zone' in obj.locality && typeof obj.locality.zone !== 'string') {
            throw new Error('lrs config locality.zone field must be a string if provided');
        }
        if ('sub_zone' in obj.locality && typeof obj.locality.sub_zone !== 'string') {
            throw new Error('lrs config locality.sub_zone field must be a string if provided');
        }
        if (!('child_policy' in obj && Array.isArray(obj.child_policy))) {
            throw new Error('lrs config must have a child_policy array');
        }
        return new LrsLoadBalancingConfig(obj.cluster_name, obj.eds_service_name, obj.lrs_load_reporting_server_name, {
            region: (_a = obj.locality.region) !== null && _a !== void 0 ? _a : '',
            zone: (_b = obj.locality.zone) !== null && _b !== void 0 ? _b : '',
            sub_zone: (_c = obj.locality.sub_zone) !== null && _c !== void 0 ? _c : ''
        }, obj.child_policy.map(validateLoadBalancingConfig));
    }
}
exports.LrsLoadBalancingConfig = LrsLoadBalancingConfig;
/**
 * Filter class that reports when the call ends.
 */
class CallEndTrackingFilter extends BaseFilter {
    constructor(localityStatsReporter) {
        super();
        this.localityStatsReporter = localityStatsReporter;
    }
    receiveTrailers(status) {
        this.localityStatsReporter.addCallFinished(status.code !== grpc_js_1.status.OK);
        return status;
    }
}
class CallEndTrackingFilterFactory {
    constructor(localityStatsReporter) {
        this.localityStatsReporter = localityStatsReporter;
    }
    createFilter(callStream) {
        return new CallEndTrackingFilter(this.localityStatsReporter);
    }
}
/**
 * Picker that delegates picking to another picker, and reports when calls
 * created using those picks start and end.
 */
class LoadReportingPicker {
    constructor(wrappedPicker, localityStatsReporter) {
        this.wrappedPicker = wrappedPicker;
        this.localityStatsReporter = localityStatsReporter;
    }
    pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === PickResultType.COMPLETE) {
            const trackingFilterFactory = new CallEndTrackingFilterFactory(this.localityStatsReporter);
            /* In the unlikely event that the wrappedPick already has an
             * extraFilterFactory, preserve it in a FilterStackFactory. */
            const extraFilterFactory = wrappedPick.extraFilterFactory
                ? new FilterStackFactory([
                    wrappedPick.extraFilterFactory,
                    trackingFilterFactory,
                ])
                : trackingFilterFactory;
            return {
                pickResultType: PickResultType.COMPLETE,
                subchannel: wrappedPick.subchannel,
                status: null,
                onCallStarted: () => {
                    var _a;
                    (_a = wrappedPick.onCallStarted) === null || _a === void 0 ? void 0 : _a.call(wrappedPick);
                    this.localityStatsReporter.addCallStarted();
                },
                extraFilterFactory: extraFilterFactory,
            };
        }
        else {
            return wrappedPick;
        }
    }
}
/**
 * "Load balancer" that delegates the actual load balancing logic to another
 * LoadBalancer class and adds hooks to track when calls started using that
 * LoadBalancer start and end, and uses the XdsClient to report that
 * information back to the xDS server.
 */
class LrsLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.localityStatsReporter = null;
        this.childBalancer = new ChildLoadBalancerHandler({
            createSubchannel: (subchannelAddress, subchannelArgs) => channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs),
            requestReresolution: () => channelControlHelper.requestReresolution(),
            updateState: (connectivityState, picker) => {
                if (this.localityStatsReporter !== null) {
                    picker = new LoadReportingPicker(picker, this.localityStatsReporter);
                }
                channelControlHelper.updateState(connectivityState, picker);
            },
        });
    }
    updateAddressList(addressList, lbConfig, attributes) {
        if (!(lbConfig instanceof LrsLoadBalancingConfig)) {
            return;
        }
        this.localityStatsReporter = xds_client_1.getSingletonXdsClient().addClusterLocalityStats(lbConfig.getLrsLoadReportingServerName(), lbConfig.getClusterName(), lbConfig.getEdsServiceName(), lbConfig.getLocality());
        const childPolicy = getFirstUsableConfig(lbConfig.getChildPolicy(), true);
        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.LrsLoadBalancer = LrsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, LrsLoadBalancer, LrsLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-lrs.js.map