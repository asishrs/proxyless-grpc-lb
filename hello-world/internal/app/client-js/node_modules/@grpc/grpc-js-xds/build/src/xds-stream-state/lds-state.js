"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdsState = void 0;
const protoLoader = require("@grpc/proto-loader");
const grpc_js_1 = require("@grpc/grpc-js");
const TRACER_NAME = 'xds_client';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const HTTP_CONNECTION_MANGER_TYPE_URL = 'type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager';
class LdsState {
    constructor(rdsState, updateResourceNames) {
        this.rdsState = rdsState;
        this.updateResourceNames = updateResourceNames;
        this.versionInfo = '';
        this.nonce = '';
        this.watchers = new Map();
        this.latestResponses = [];
    }
    addWatcher(targetName, watcher) {
        trace('Adding RDS watcher for targetName ' + targetName);
        let watchersEntry = this.watchers.get(targetName);
        let addedServiceName = false;
        if (watchersEntry === undefined) {
            addedServiceName = true;
            watchersEntry = [];
            this.watchers.set(targetName, watchersEntry);
        }
        watchersEntry.push(watcher);
        /* If we have already received an update for the requested edsServiceName,
         * immediately pass that update along to the watcher */
        for (const message of this.latestResponses) {
            if (message.name === targetName) {
                /* These updates normally occur asynchronously, so we ensure that
                 * the same happens here */
                process.nextTick(() => {
                    trace('Reporting existing RDS update for new watcher for targetName ' + targetName);
                    watcher.onValidUpdate(message);
                });
            }
        }
        if (addedServiceName) {
            this.updateResourceNames();
        }
    }
    removeWatcher(targetName, watcher) {
        trace('Removing RDS watcher for targetName ' + targetName);
        const watchersEntry = this.watchers.get(targetName);
        let removedServiceName = false;
        if (watchersEntry !== undefined) {
            const entryIndex = watchersEntry.indexOf(watcher);
            if (entryIndex >= 0) {
                watchersEntry.splice(entryIndex, 1);
            }
            if (watchersEntry.length === 0) {
                removedServiceName = true;
                this.watchers.delete(targetName);
            }
        }
        if (removedServiceName) {
            this.updateResourceNames();
        }
    }
    getResourceNames() {
        return Array.from(this.watchers.keys());
    }
    validateResponse(message) {
        var _a, _b, _c, _d, _e;
        if (!(((_a = message.api_listener) === null || _a === void 0 ? void 0 : _a.api_listener) &&
            protoLoader.isAnyExtension(message.api_listener.api_listener) &&
            ((_b = message.api_listener) === null || _b === void 0 ? void 0 : _b.api_listener['@type']) ===
                HTTP_CONNECTION_MANGER_TYPE_URL)) {
            return false;
        }
        const httpConnectionManager = (_c = message.api_listener) === null || _c === void 0 ? void 0 : _c.api_listener;
        switch (httpConnectionManager.route_specifier) {
            case 'rds':
                return !!((_e = (_d = httpConnectionManager.rds) === null || _d === void 0 ? void 0 : _d.config_source) === null || _e === void 0 ? void 0 : _e.ads);
            case 'route_config':
                return this.rdsState.validateResponse(httpConnectionManager.route_config);
        }
        return false;
    }
    handleMissingNames(allTargetNames) {
        for (const [targetName, watcherList] of this.watchers.entries()) {
            if (!allTargetNames.has(targetName)) {
                for (const watcher of watcherList) {
                    watcher.onResourceDoesNotExist();
                }
            }
        }
    }
    handleResponses(responses) {
        var _a;
        for (const message of responses) {
            if (!this.validateResponse(message)) {
                trace('LDS validation failed for message ' + JSON.stringify(message));
                return 'LDS Error: Route validation failed';
            }
        }
        this.latestResponses = responses;
        const allTargetNames = new Set();
        for (const message of responses) {
            allTargetNames.add(message.name);
            const watchers = (_a = this.watchers.get(message.name)) !== null && _a !== void 0 ? _a : [];
            for (const watcher of watchers) {
                watcher.onValidUpdate(message);
            }
        }
        trace('Received RDS response with route config names ' + Array.from(allTargetNames));
        this.handleMissingNames(allTargetNames);
        return null;
    }
    reportStreamError(status) {
        for (const watcherList of this.watchers.values()) {
            for (const watcher of watcherList) {
                watcher.onTransientError(status);
            }
        }
    }
}
exports.LdsState = LdsState;
//# sourceMappingURL=lds-state.js.map